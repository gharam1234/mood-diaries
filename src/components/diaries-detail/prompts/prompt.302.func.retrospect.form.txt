아래의 조건을 모두 적용하여, 아래의 요구사항을 모두 구현할 것.
구현 결과를 체크리스트로 반환할 것.

==============================================

조건-커서룰) 아래의 커서룰을 적용하여 작업하고, 이 작업이 끝나면 해당 rules 적용 결과를 체크리스트로 반환할 것.
            - @01-common.mdc
            - @04-func.mdc

==============================================

조건-파일경로) 참고할 TSX  파일경로: src/components/diaries-detail/index.tsx
조건-파일경로) 참고할 CSS  파일경로: src/components/diaries-detail/styles.module.css
조건-파일경로) 구현될 HOOK 파일경로: src/components/diaries-detail/hooks/index.retrospect.form.hook.ts
조건-파일경로) 구현될 TEST 파일경로: src/components/diaries-detail/tests/index.retrospect.form.hook.spec.ts

==============================================

핵심요구사항) 병렬처리 구현을 위한 작업 방식 조건
            - 다른 채팅에서 개발중인 파일을 수정 및 삭제 하지 말 것.
            - 테스트 충돌을 방지하기 위해, 빌드테스트, 전체테스트를 하지 말 것.

핵심요구사항) 다음의 기능을 playwright 테스트를 활용하여 TDD기반으로 구현하고, 테스트에 통과할 때까지 반복할 것.
            1) 테스트 제외 라이브러리
                - jest
                - @testing-library/react

            2) 테스트 조건
                - timeout은 설정하지 않거나, 500ms 미만으로 설정할 것.
                - 모든 페이지의 로드 식별 조건은 아래를 따를 것.
                    - 페이지 로드 식별 요구사항: 고정식별자 data-testid 대기 방법
                    - 페이지 로드 식별 금지사항: networkidle 대기 방법

            3) 테스트 로컬스토리지 조건
                3-1) 데이터
                    - 실제데이터를 사용할 것.
                    - Mock데이터 사용하지 말 것.

                3-2) 성공시나리오
                    - 로컬스토리지 모킹하지 말 것.

                3-3) 실패시나리오
                    - 로컬스토리지 모킹하지 말 것.

            4) 테스트 데이터타입
                - 저장소: 로컬스토리지
                - key: retrospects
                - value: [{
                    id: number,
                    content: string,
                    diaryId: number => 연결된 diaryId를 그대로 저장할 것.
                    createdAt: string,
                }]

            5) 테스트시나리오(로그인유저)
                1. /diaries/[id]에 접속하여 페이지 로드 확인
                2. 하단 유저시나리오에 적절한 테스트시나리오를 생성하여 진행

핵심요구사항) 다음의 조건에 맞게 회고쓰기 폼 등록 기능을 step-by-step 으로 구현하고, 적용 결과를 체크리스트로 반환할 것.
            1) 라이브러리조건
                - 폼: 이미 설치되어있는 react-hook-form, @hookform/resolvers를 사용할 것.
                - 검증: 이미 설치되어있는 zod를 사용할 것.

            2) 유저시나리오(회고 등록하기)
                1. 회고등록 인풋이 입력되면 입력버튼을 활성화 할 것.
                2. 등록하기버튼을 클릭시, 로컬스토리지에 이미 retrospects가 존재하는지 확인하고,
                    존재하면 기존의 retrospects에 push하되, id를 가장큰 id+1로 설정하여 재등록하고,
                    존재하지 않으면 새로운 retrospects 배열을 생성하여 id는 1로 설정하여 등록할 것.
                3. 등록이 완료되면, 현재 페이지를 새로고침 할 것.

==============================================

세부구현요구사항) useRetrospectForm 훅 구현

1) 훅 함수 시그니처
   ```typescript
   export const useRetrospectForm = (diaryId: number) => {
     // 구현
   }
   ```
   - 매개변수: diaryId - 현재 일기의 ID (로컬스토리지 저장 시 사용)
   - 반환값: { form, isSubmitEnabled, onSubmit }

2) 회고 폼 검증 스키마 (Zod)
   - content 필드:
     * 필수입력 (min: 1)
     * 최대길이: 500자
     * trim() 적용
   - 에러메시지:
     * 빈입력: '회고 내용을 입력해주세요.'
     * 길이초과: '회고 내용은 500자 이하로 입력해주세요.'

3) react-hook-form 설정
   - resolver: zodResolver(스키마) 사용
   - defaultValues: { content: '' }
   - mode: 'onChange' (입력 시 실시간 검증)

4) 입력버튼 활성화 상태 (isSubmitEnabled)
   - content 필드를 watch하여 값 모니터링
   - 조건: content가 존재하고 trim() 후 길이 > 0일 때만 true
   - 삼항연산자나 && 연산자를 활용하여 간결하게 구현

5) onSubmit 핸들러 구현
   - form.handleSubmit()을 사용하여 async 핸들러 래핑
   - 다음 단계 순서로 구현:

   Step 1) 기존 회고 데이터 조회
           - getExistingRetrospects() 함수 호출
           - 로컬스토리지 'retrospects' 키에서 조회
           - 데이터 없거나 파싱 실패 시 빈배열 반환
           - try-catch로 에러 처리

   Step 2) 새로운 ID 생성
           - generateNewId(existingRetrospects) 함수 사용
           - 기존 데이터가 없으면: ID = 1
           - 기존 데이터가 있으면: ID = max(기존ID들) + 1
           - Math.max()와 map()을 활용

   Step 3) 새로운 회고 데이터 객체 생성
           - RetrospectData 타입 준수:
             {
               id: 생성된 ID,
               content: data.content.trim(),
               diaryId: 함수 매개변수의 diaryId,
               createdAt: 현재 날짜 (한국 로케일, 'YYYY. MM. DD' 형식)
             }
           - createdAt 생성:
             * new Date().toLocaleDateString('ko-KR', {
                 year: 'numeric',
                 month: '2-digit',
                 day: '2-digit'
               })
             * 후처리로 '. ' 일관성 확인 (replace(/\. /g, '. '))

   Step 4) 로컬스토리지에 저장
           - saveRetrospectToStorage(newRetrospect) 함수 사용
           - 기존 데이터에 새 데이터 push
           - JSON.stringify()로 직렬화
           - localStorage.setItem('retrospects', ...)
           - 실패 시 에러 로깅 및 throw

   Step 5) 폼 초기화
           - form.reset()
           - content 필드를 초기상태로 복원

   Step 6) 페이지 새로고침
           - router.refresh() 호출 (Next.js App Router)
           - 백엔드 데이터 재조회 및 UI 갱신

   Step 7) 에러 처리
           - try-catch로 전체 래핑
           - 에러 발생 시:
             * console.error() 로깅
             * 에러 메시지 표시 또는 throw
             * 사용자에게 실패 알림 (필요시)

6) 헬퍼 함수 구현 (onSubmit 내부에서 사용)

   함수명: getExistingRetrospects()
   - 설명: 로컬스토리지에서 기존 회고 데이터 조회
   - 반환: RetrospectData[]
   - 구현:
     * try-catch로 에러 처리
     * localStorage.getItem('retrospects') 조회
     * 데이터 있으면 JSON.parse()
     * 데이터 없으면 빈배열 []
     * 파싱 실패 시 에러 로깅 후 빈배열

   함수명: generateNewId(existingRetrospects: RetrospectData[])
   - 설명: 다음 회고 ID 자동 생성
   - 반환: number
   - 구현:
     * 배열이 비어있으면: 1 반환
     * 배열이 있으면:
       - existingRetrospects.map(r => r.id) 로 ID 배열 추출
       - Math.max(...ID배열) 로 최대값 구하기
       - 최대값 + 1 반환

   함수명: saveRetrospectToStorage(retrospect: RetrospectData)
   - 설명: 새로운 회고 데이터를 로컬스토리지에 저장
   - 반환: void
   - 구현:
     * getExistingRetrospects() 로 기존 데이터 조회
     * 스프레드 연산자로 새 배열 생성: [...existingRetrospects, retrospect]
     * localStorage.setItem('retrospects', JSON.stringify(updatedArray))
     * try-catch로 에러 처리 및 throw

==============================================

테스트 구현 요구사항) index.retrospect.form.hook.spec.ts

1) 테스트 설정
   - Playwright 테스트 프레임워크 사용
   - test.describe.configure({ mode: 'serial' }) 적용

2) 테스트 시나리오 1: 입력 시 버튼 활성화 및 데이터 저장
   테스트명: '입력 시 버튼 활성화, 저장 후 새로고침 및 데이터 검증'

   실행 단계:
   a) beforeEach에서:
      - page.goto('/') 로 origin 설정
      - 로컬스토리지에 테스트용 diaries 데이터 주입
        * id: 1, title: 테스트제목, content: 테스트내용, emotion: HAPPY, createdAt: '2024. 01. 01'
      - 로컬스토리지의 retrospects 제거 (removeItem)

   b) 테스트 본문:
      1. page.goto('/diaries/1', { waitUntil: 'domcontentloaded' })
      2. input[placeholder="회고를 남겨보세요."] 인풋 선택 및 대기
      3. input.fill('오늘의 배움: TDD로 회고 기능 추가')
      4. button:has-text("입력") 선택 및 활성화 상태 확인 (timeout: 500ms)
      5. submitButton.click()
      6. [data-testid="diary-detail-container"] 대기 (timeout: 5000ms)
      7. 로컬스토리지에서 retrospects 데이터 추출 및 검증:
         - Array.isArray(retrospects) === true
         - retrospects.length === 1
         - retrospects[0].id === 1
         - retrospects[0].diaryId === 1
         - typeof retrospects[0].createdAt === 'string'
         - retrospects[0].content === '오늘의 배움: TDD로 회고 기능 추가'

3) 테스트 시나리오 2: ID 증가 로직 검증
   테스트명: '기존 데이터가 있을 때 id가 가장 큰 값 + 1로 증가 저장'

   실행 단계:
   a) beforeEach는 시나리오 1과 동일

   b) 테스트 본문:
      1. page.goto('/diaries/1', { waitUntil: 'domcontentloaded' })
      2. input[placeholder="회고를 남겨보세요."] 인풋 선택 및 대기
      3. page.evaluate()로 기존 회고 데이터 주입:
         - ID: 1, content: 기존 회고 1, diaryId: 1, createdAt: '2024. 09. 24'
         - ID: 3, content: 기존 회고 3, diaryId: 1, createdAt: '2024. 09. 25'
         (주의: 실제 로컬스토리지 사용, 모킹 없음)
      4. input.fill('새 회고 - 증가 ID 확인')
      5. button:has-text("입력") 선택 및 활성화 상태 확인 (timeout: 500ms)
      6. submitButton.click()
      7. [data-testid="diary-detail-container"] 대기 (timeout: 5000ms)
      8. 로컬스토리지에서 retrospects 데이터 추출 및 마지막 항목 검증:
         - newest.id === 4 (max(1, 3) + 1)
         - newest.content === '새 회고 - 증가 ID 확인'
         - newest.diaryId === 1

4) 테스트 실행 조건
   - timeout 설정: 500ms 이하 (명시적 timeout 제외 시 기본값)
   - 페이지 로드: data-testid 대기 방식만 사용
   - 로컬스토리지: 실제 데이터 사용, 모킹 금지
   - 성공/실패 시나리오 모두: 로컬스토리지 모킹 금지

==============================================

검증체크리스트) 구현 완료 후 아래 항목들을 모두 만족하는지 확인할 것

구현 관련:
☐ useRetrospectForm 훅이 정상적으로 구현되었는가
☐ react-hook-form과 zod 스키마가 올바르게 연동되었는가
☐ isSubmitEnabled 상태가 입력값에 따라 정확히 토글되는가
☐ 로컬스토리지에 'retrospects' 키로 데이터가 저장되는가
☐ ID 자동 생성 로직이 max ID + 1로 정확히 동작하는가
☐ 첫 데이터 저장 시 ID가 1로 설정되는가
☐ createdAt이 'YYYY. MM. DD' 형식으로 저장되는가
☐ diaryId가 함수 매개변수로 받은 값이 정확히 저장되는가
☐ 저장 후 router.refresh()가 호출되어 페이지가 갱신되는가
☐ 폼이 저장 후 초기화되는가 (content: '')

테스트 관련:
☐ Playwright 테스트가 작성되었는가
☐ 테스트 1: 입력 시 버튼 활성화 및 저장 검증이 통과하는가
☐ 테스트 2: ID 증가 로직 검증이 통과하는가
☐ timeout이 500ms 이하로 설정되었는가
☐ 페이지 로드가 data-testid 대기 방식을 사용하는가
☐ 로컬스토리지가 실제 데이터를 사용하는가 (모킹 없음)
☐ 로컬스토리지 데이터 구조가 명세와 일치하는가

코드품질:
☐ JSDoc 주석이 모든 함수에 포함되었는가
☐ 에러 처리가 try-catch로 구현되었는가
☐ 변수명과 함수명이 명확하고 일관성있는가
☐ 코드 포맷팅이 프로젝트 스타일을 따르는가

==============================================

추가 고려사항)

1) 컴포넌트 연동
   - DiariesDetail 컴포넌트에서 useRetrospectForm(diaryId) 훅을 호출
   - form.watch('content')로 입력값 모니터링
   - isSubmitEnabled를 버튼 disabled 속성에 연동
   - onSubmit을 버튼 onClick 핸들러에 연동

2) 로컬스토리지 데이터 관리
   - 기존 데이터와의 호환성 유지
   - JSON 직렬화/역직렬화 에러 처리
   - 날짜 형식 일관성 유지

3) UX 개선
   - 입력 중 실시간 검증 (mode: 'onChange')
   - 저장 완료 후 입력 필드 자동 초기화
   - 페이지 새로고침으로 최신 데이터 표시

4) 에러 처리 전략
   - 로컬스토리지 접근 실패 시 콘솔 로깅
   - 폼 검증 실패 시 에러 메시지 표시
   - 사용자 입력 예외 상황 대응

==============================================
